import numpy as np

def b_series_coeff(AE_AO, P_D, J, Z):
    """
    Calculates Wageningen B-Series Thrust (KT) and Torque (KQ) coefficients.
    
    Inputs:
        AE_AO: Expanded area ratio (Ae/Ao)
        P_D:   Pitch-diameter ratio (P/D)
        J:     Advance coefficient (Va / nD) - can be an array
        Z:     Blade count
    """
    J = np.atleast_1d(J)
    
    # Coefficients and Exponents for KT
    C_T = np.array([
        0.00880496, -0.204554, 0.166351, 0.158114, -0.147581, -0.481497, 0.415437, 
        0.0144043, -0.0530054, 0.0143481, 0.0606826, -0.0125894, 0.0109689, -0.133698, 
        0.00638407, -0.00132718, 0.168496, -0.0507214, 0.0854559, -0.0504475, 0.010465, 
        -0.00648272, -0.00841728, 0.0168424, -0.00102296, -0.0317791, 0.018604, 
        -0.00410798, -0.000606848, -0.0049819, 0.0025983, -0.000560528, -0.00163652, 
        -0.000328787, 0.000116502, 0.000690904, 0.00421749, 0.0000565229, -0.00146564
    ])
    s_T, t_T, u_T, v_T = [np.array(x) for x in [
        [0, 1, 0, 0, 2, 1, 0, 0, 2, 0, 1, 0, 1, 0, 0, 2, 3, 0, 2, 3, 1, 2, 0, 1, 3, 0, 1, 0, 0, 1, 2, 3, 1, 1, 2, 0, 0, 3, 0],
        [0, 0, 1, 2, 0, 1, 2, 0, 0, 1, 1, 0, 0, 3, 6, 6, 0, 0, 0, 0, 6, 6, 3, 3, 3, 3, 0, 2, 0, 0, 0, 0, 2, 6, 6, 0, 3, 6, 3],
        [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 2, 2, 2, 2, 2, 0, 0, 0, 1, 2, 2, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2],
        [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
    ]]

    # Coefficients and Exponents for KQ
    C_Q = np.array([
        0.00379368, 0.00886523, -0.032241, 0.00344778, -0.0408811, -0.108009, -0.0885381, 
        0.188561, -0.00370871, 0.00513696, 0.0209449, 0.00474319, -0.00723408, 0.00438388, 
        -0.0269403, 0.0558082, 0.0161886, 0.00318086, 0.015896, 0.0471729, 0.0196283, 
        -0.0502782, -0.030055, 0.0417122, -0.0397722, -0.00350024, -0.0106854, 0.00110903, 
        -0.000313912, 0.0035985, -0.00142121, -0.00383637, 0.0126803, -0.00318278, 0.00334268, 
        -0.00183491, 0.000112451, -0.0000297228, 0.000269551, 0.00083265, 0.00155334, 
        0.000302683, -0.0001843, -0.000425399, 0.0000869243, -0.0004659, 0.0000554194
    ])
    s_Q, t_Q, u_Q, v_Q = [np.array(x) for x in [
        [0, 2, 1, 0, 0, 1, 2, 0, 1, 0, 1, 2, 2, 1, 0, 3, 0, 1, 0, 1, 3, 0, 3, 2, 0, 0, 3, 3, 0, 3, 0, 1, 0, 2, 0, 1, 3, 3, 1, 2, 0, 0, 0, 0, 3, 0, 1],
        [0, 0, 1, 2, 1, 1, 1, 2, 0, 1, 1, 1, 0, 1, 2, 0, 3, 3, 0, 0, 0, 1, 1, 2, 3, 6, 0, 3, 6, 0, 6, 0, 2, 3, 6, 1, 2, 6, 0, 0, 2, 6, 0, 3, 3, 6, 6],
        [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 2, 2, 2, 2, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2],
        [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
    ]]

    # Vectorized calculation
    KT = np.sum(C_T[:, None] * (J**s_T[:, None]) * (P_D**t_T[:, None]) * (AE_AO**u_T[:, None]) * (Z**v_T[:, None]), axis=0)
    KQ = np.sum(C_Q[:, None] * (J**s_Q[:, None]) * (P_D**t_Q[:, None]) * (AE_AO**u_Q[:, None]) * (Z**v_Q[:, None]), axis=0)
    
    return KT, KQ

if __name__ == '__main__':
    print(b_series_coeff(0.6, 1.4, [0.4,1], 3))